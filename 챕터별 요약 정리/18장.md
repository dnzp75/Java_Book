# 자바의 신 18장 요약

**■ 1. 객체지향 개발과 관련된 용어들 ■**

**■ 1-1. 객체지향 관련 용어 목록**

- **클래스 :** "상태"와 "행위"를 갖는 자바의 기본 단위를 의미한다.
- **상태와 행위 :** 어떤 사물을 나타낼 때에는 상태와 행위로 구분하여 표시하는 것이 가능하다. 자바에서 "상태"는 클래스나 인스턴스 변수로, "헹위"는 메소드로 표현할 수 있다.
- **캡슐화 :** 연결된 "상태"와 "행위"를 결정하는 기능을 묶어주는 것을 의미한다.
- **메시지 :** 메소드에서 다른 메소드를 호출할 때 전달하는 값을 메시지라고 한다. 자바에서는 메소드를 호출할 때 넘겨주는 매개 변수들이 여기에 속한다.
- **객체 :** 클래스는 사물의 단위를 의미하지만, 객체는 각 사물을 의미한다. 예를 들어 "godOfJava"는 책 중의 하나를 의미하는 객체라고 볼 수 있다. [ Book godOfJava = new Book(); ]
- **상속 :** 부모에 선언된 변수와 메소드에 대한 사용권을 갖는 것을 말한다. 즉, 클래스 선언시 extends를 사용하여 확장하거나, implement를 사용하여 구현한 경우가 여기에 속한다.
- **Overriding :** 부모 클래스에 선언되어 있는 메소드와 동일한 선언을 갖지만 구현이 다른것(내가 원하는 형식으로)을 의마한다.
- **다형성(Polymorphism) :** 이 세상에 부모와 자식이 똑같을 수가 없고, 자식들도 같을 수가 없다. 마찬가지로 자바에서는 부모 클래스에서 파생된 자식 클래스들의 기능이 각기 다를 수 있다는 것을 의미한다.
- **Overloading :** 메소드의 이름은 동일해도, 매개변수들을 다르게 하는 것을 의미한다. 그래서 동일한 기능은 하지만, 메소드에 넘겨 줄 수 있는 매개 변수의 타입을 다양하게 함으로싸 메소드를 사용하는 다른 개발자가 쉽게 구현할 수 있게 해준다.

---

**■ 1-2. 자바의 주석문**

주석은 개발하면서 부연 설명을 추가하거나, 개발해 놓은 코드를 임시로 수행하지 않도록 하려고 사용한다.

**한 줄 주석(//) :** 일반적으로 해당 줄을 실행하지 않도록 사용

**블록 주석(/* */) :** 여러 줄을 실행하지 않도록 할 때 사용

**javadoc을 위한 주석(/** */) :** API 문서에 설명을 표시할 목적으로 사용

---

**■ 1-3. 패키지와 import**

패키지는 클래스들 그룹화하기 위한 단위이다. 만약 이러한 패키지가 없다면, 자바의 소스코드들은 하나의 폴더 안에서 연관성 없이 뒤죽 박죽되어 매우 복작해질 것이다.

만약 다른 패키지에 선언되어 있는 클래스를 사용하기 위해서는 클래스 선언 앞에 **import** 문장들이 있어야 한다.

- **패키지 선언시 유의사항들**
    - 패키지는 package로 시작하면 하위 패키지로 내려갈 때마다 .을 찍어 주어야 한다.
    - 반드시 소스의 가장 첫 줄에 존재해야 한다.
    - 패키지 이름에 자바 예약어가 포함되면 안된다.
    - 모두 소문자로 구성하는 것이 일반적이다.
    - 일반적인 패키지는 java나 javax로 시작하면 안된다.
    - 패키지에 해당하는 폴더에 클래스가 존재하는 것이 일반적이다.
- **import는**
    - 다른 패키지에 있는 클래스를 사용하기 위한 문장이다.
    - 다른 클래스에 static으로 선언되어 있는 접근 가능한 변수를 참조하려면 import static을 사용한다.
    - 하나의 패키지 내에 있는 모든 클래스를 참조하려면 *을 사용한다.
    - ex) import static com.roadbook.godofjava , import com.roadbook.godofjava

---

**■ 1-4. 자바에서 사용되는 타입의 종류**

자바의 타입은 크게 기본자료형과 참조자료형으로 나뉜다.

기본자료형 : 정수형(byte, short, int, long, char), 소수형(float, double), 기타(boolean)

!https://blog.kakaocdn.net/dn/bcjIEP/btrL5xFHPuN/7bHgTprDF198lVooFIfUDK/img.png

참조자료형 : 기본 자료형을 제외한 모든 타입을 말한다. 모든 클래스는 참조 자료형이라고 생각하면 된다.

- **참조 자료형과 기본 자료형의 차이**
    - 초기화 할 때 : 기본 자료형은 값을 바로 지정하면 되지만, 참조자료형은 일반적으로 new와 생성자를 지정하여 객체를 생성한다.
    - 메소드를 호출할 때의 매개변수 : 기본자료형 및 참조자료형 모두 값을 전달하지만, 참조자료형 안에 있는 변수들은 참조 주소를 전달한다.[ **heap영역에 있는 실제 값이 있고, stack영역에서 heap 영역에 있는 실제값을 래퍼런스 변수로 참조한다.** ]
- **특수한 참조 자료형**
    - String : String 클래스는 new를 이용하여 객체를 생성할 필요가 없는 특수한 클래스이다. 또한 +연산까지 가능한 유일클래스다.[ **String에서 +연산을 했을시 불변객체이기 때문에 heap영역에서 기존 오브젝트를 변경하는 것이 아니라 새로운 오브젝트를 생성한다.** ]

---

**■ 1-5. 변수의 종류**

자바에서 사용되는 변수의 종류는 4가지다.

- **자바 변수의 종류**
    - 지역변수 : 지역변수를 선언한 곳에서부터 생명이 시작되고, 지역변수를 선언한 중괄호가 끝나면 소멸
    - 매개변수 : 메소드가 호출될 때 생명이 시작되고, 메소드가 끝나면 소멸(호출한 메소드에서 넘겨준 참조 자료형은 그대로 살아 있음[ pass by reference : https://bj-turtle.tistory.com/70 )
    - 인스턴스변수 : 객체가 생성될 때 생명이 시작되고, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸
    - 클래스 변수 : 클래스가 생성될 대 생명이 시작되고, 자바 프로그램이 끝날 때 소멸

[EX]

```java
public class VariableTypes {
	int instanceVariable;
    static int classVariable;
    public void method(int parameter){
    	int localVariable;
    }
}
```

---

**■ 1-6. 계산을 쉽게 도와주는 연산자들**

!https://blog.kakaocdn.net/dn/dqfXR2/btrL9I6Nhya/SbYI1jEEmJNqKiGiONAq00/img.png

삼항 연산자는 다음과 같이 사용하면 된다.

> 변수 = (boolean조건식) ? true일때의 값 : false일때의 값 ;
> 

---

**■ 1-7. 조건문들**

변수들의 상태에 따라서 프로그램을 분기할 필요가 있을때 사용하는 조건문들은 다음과 같다.

**[ if ]**

> if(boolean값) 처리문장;
> 

**[ if-else ]**

> if(boolean값) 처리문장 1;
> 

처리 문장이 두 줄 이상일 때에는

> if(boolean 값) {
> 

**[ if-else if ]**

> if(boolean 값) 처리문장 1;
> 

**[ if-else if ]**

> switch(비교대상변수) {
> 

---

**■ 1-8. 반복문들**

**[ while ]**

> while(boolean조건이 true 일 경우 실행) {
> 

**[ do - whilde : 반복 수행을 하기 전에 적어도 한 번은 처리할 필요가 있을 경우 사용 ]**

> do {
> 

**[ for 루프 : for 루프가 수행되는 순서는 다음과 같음 ]**

> for (초기화; 종료조건; 조건값 증가) {
> 

**조건을 빠져 나오기 위한 break**

조건문이나 본복문의 중간에서 하던 작업을 중단할 필요가 있을 때 break를 사용한다.

**검증 로직으로 이동하기 위한 continue**

반복문에서 중간에서 하던 작업을 중단하고, 조건을 확인하는 부분으로 바로 이동하기 위해서 사용한다.

---

**■ 1-9. 아무나 사용 못하게 막아주는 접근 제어자**

자바는 4가지 접근 제어자를 제공한다.

이 접근 제어자는 클래스, 변수, 메소드 등을 선언할 때 사용하고, 선언한 해당 항목의 범위를 제한하는것이 목적이다.

- public : 누구나 접근 가능하다.
- protected : 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능하다.
- (package-private) : 아무런 접근 제어자를 적어주지 않을때이며, package-private 라고도 불린다. 같은 패키지 내에 있을때만 접근 가능하다.
- private : 해당 클래스 내에서만 접근 가능하다.

!https://blog.kakaocdn.net/dn/nz7A7/btrL80AoyaJ/RRdpkZGkvGK7g7m2PBDtdK/img.png

---

**■ 1-10. 선언할 때 사용할 수 있는 각종 제어자들**

클래스, 메소드, 변수를 선언할 때 사용할 수 있는 제어자는 접근 제어자만 있는 것이 아니다.

어떤 제어자들을 어디에서 사용할 수 있는지 정리해보자.

!https://blog.kakaocdn.net/dn/eblUSN/btrL9pTWBTn/eiBdxabf37wWiTav4AqFO1/img.png

---

**■ 1-11. 자바를 구성하는 클래스, 인터페이스, abstract 클래스**

- **자바에서 만든 코드를 관리하는 클래스 파일(.class)이 되는 타입의 종류**
    - 클래스
    - 인터페이스
    - abstract 클래스
    - enum 클래스
    - 어노테이션 선언 클래스
- **인터페이스와 absract 클래스, 클래스의 차이**
    1. **인터페이스**
        - 어떤 메소드가 존재해야 하는지에 대한 선언만 되어 있다.
        - 절대로 구현되어 있는 메소드가 있어서는 안된다.
        - 인터페이스를 구현하는 클래스에서는 implements를 사용하여 선언한다.
    2. **abstract 클래스**
        - 구현되어 잇는 메소드가 있어도 상관없다.
        - abstarct으로 선언된 메소드가 1개 이상일 경우에는 반드시 abstract 클래스로 선언해야 한다.
        - abstact으로 선언된 메소드는 절대로 구현되어 있어서는 안된다.
        - abstact 클래스를 확장하는 클래스에서는 extends를 사용하여 선언한다.
    3. **클래스**
        - 인터페이스나 abstract 클래스와 다르게 모든 메소드가 구현되어 있어야 한다.

**클래스, 인터페이스, abstract 클래스의 차이 표**

!https://blog.kakaocdn.net/dn/bLgXIj/btrMaIecNMl/OIrbVuNg0300bFN9ydHTq0/img.png

**클래스 선언 예**

> public class Sample extends SuperClass implements InterfaceA, InterfaceB {
> 
- sample이라는 이름을 가지는 클래스 선언
    - 파일 이름은 Sample.java
    - 대문자로 시작하고, 추가 단어가 있을 경우에는 첫 문자만 대문자를 사용한다.
    - 접근 제어자를 포함한 앞 절에서 설명한 접근 제어자 사용 가능하다.
- SuperClass라는 클래스를 확장
    - extends 뒤에 부모 클래스의 이름을 명시하며, 반드시 하나의 클래스만 지정 가능하다.
    - abstract 클래스도 extends로 확장할 수 있다.
- InterfaceA와 InterfaceB를 구현함
    - 한 개 이상의 구현할 인터페이스 이름을 명시한다.
    - implements로 구현을 한다고 명시할 때에는 인터페이스에 선언된 모든 메소드가 이 클래스에서 구현 되어야 한다.

**인터페이스 선언 예**

> public interface InterfaceA {
> 

구현되어 있는 메소드가 하나도 있으면 안된다.

**abstract 선언 예**

> public abstact class AbstractClass{
> 

abstarct으로 선언된 메소드가 하나라도 있을 경우 클래스를 absract으로 선언되어야만 한다.

**enum 클래스 선언 예**

> public enum EnumClass {
> 
- enum 클래스는 상수를 열거하기 위한 용도로 사용한다.
- enum클래스의 상수는 이름만 정의해도 된다.
- 별도의 생성자를 만들어 각 상수의 값을 지정할 수 있다.
- 모든 enum 클래스의 부모 클래스는 java.lang.Enum 클래스뿐이다.
- enum에 메소드를 만들어 기능 추가 가능

**어노테이션 선언 예**

> import java.lang.annotation.*;
> 
- 대상(@Target)과 적용 범위(@Retention)를 명시하는 것이 좋다.
- @interface를 사용하여 어노테이션이라는 것을 명시한다.

참고로, interface나 abstact 클래스 모두 클래스 변수나 인스턴스 변수를 선언할 수 있으며, 구현 및 확장하는 클래스에서는 이 값들을 사용할 수 있다.

---

**■ 1-12. 메소드의 선언**

메소드는 자바에서 클래스의 행위를 처리하는데 사용된다.

● **기본적인 메소드의 선언 예**

> public void method(String param, int ... params) {
> 
- method라는 이름을 갖는 메소드다.
- public과 같은 제어자 선언이 가능하다.
- void로 선언되어 있어 리턴되는 값이 없다.
- param이라는 String 타입의 매개변수를 가진다.
- params라는 여러 개의 int 타입을 콤마로 구분하여 매개 변수로 지정 가능하다.

---

**■ 1-13. 자주 사용하게 되는 상속**

자바 개발시에는 상속을 자주 사용하게 된다. 만약, 자주 사용하지 않고 상속되어 있는 클래스가 적다면, 리팩토링이라는 단계를 거쳐서 반복되는 메소드를 상위 클래스로 구분해 주는 것이 좋다.

==> 코드의 재사용성과 유지보수성, 가독성이 높아진다.

상속 관계가 발생했을 때 생성자, 메소드, 변수는 각각 어떻게 지정하고 동작하게 되는지 정리해보자.

- **생성자**
    - 자식 클래스의 생성자가 호출되면 자동으로 부모 클래스의 매개 변수가 없는 기본 생성자가 호출됨. 명시적으로 super()라고 지정 가능하다.
    - 부모 클래스의 생성자를 명시적으로 호출하려면 super()를 사용하면 된다.
- **메소드**
    - 부모 클래스에 선언된 메소드들이 자신의 클래스에 선언된 것처럼 사용 가능하다.(private 제외)
    - 부모 클래스에 선언된 메소드와 동일한 시그니처를 사용함으로써 메소드 overriding이 가능하다.
    - 부모 클래스에 선언되어 있지 않은 이름의 새로운 메소드 선언이 가능하다.
- **변수**
    - 부모 클래스에 private로 선언된 변수를 제외한 모든 변수가 자신의 클래스에 선언된 것처럼 사용 가능
    - 부모 클래스에 선언된 변수와 동일한 이름을 가지는 변수 선언 가능(권장하지 않음)
    - 부모 클래스에 선언되어 있지 않은 이름의 변수 선언 가능

---

**■ 1-14. 예외를 처리하자**

프로그램에서의 예외 상황은 언제든지 발생할 수 있다. 자바에서 발생 가능한 예외를 처리하는 것은 try-catch 문장이다.

● try-catch 기본 구문

> try {
> 
- **자바에서 사용하는 예외의 종류**
    - checked exception : try-catch로 묶어줘야 하는 예외이며, 컴파일시 예외 처리 여부를 체크한다.
    - error : 자바 프로세스에 영향을 주는 예외이며, 실행시 발생한다.
    - runtime exception 혹은 unchecked exception : try-catch로 묶지 않아도 컴파일시 체크를 하지 않는 예외이며, 실행시 발생하는 예외이다.
- **throw와 throws**
    - throw : 예외 객체를 던지기 위해서 사용한다.
    - throws : 예외가 발생하면 던질 것이라고 메소드 선언시 사용한다.
    - 메소드를 선언할 때 매개변수 소괄호 뒤에 throws라는 예약어를 적어 준 뒤 예외를 선언하면 해당 메소드에서 선언한 예외가 발생하면 호출한 메소드로 예외가 전달된다.
    - 두 가지 이상의 예외를 던지게 된다면 implements 처럼 콤마로 구분하여 예외 클래스 이름을 적어준다.
    - try 블록 내에서 예외를 발생시킬 경우에는 throw라는 예약어를 적어 준 뒤 예외 객체를 생성하거나, 생성되어있는 객체를 명시한다.
    - throw한 예외 클래스가 catch 블록에 선언되어 있지 않거나, throws 선언에 포함되어 있지 않으면 컴파일 에러가 발생한다.
    - catch 블록에서 예외를 throw할 경우에는 메소드 선언의 throws 구문에 해당 예외가 정의되어 있어야 한다.

---

**■ 1-15. Object 클래스**

Object 클래스는 모든 클래스의 가장 최상위 부모 클래스이다. 따라서, 이 클래스에 선언되어 있는 모든 메소드들은 자바에서 사용하는 모든 클래스에서 사용할 수 있다.

- Object 클래스의 주요 메소드
    - clone() : 객체의 복사본을 만들어 리턴한다.
    - equals() : 현재 객체와 매개변수로 넘겨받은 객체가 같은지 확인한다.
    - finalize() : 현재 객체가 더 이상 쓸모가 없어졌을때 가비지 컬렉터(GC)에 의해서 이 메소드가 호출된다.
    - getClass() : 현재 객체의 Class 클래스의 객체를 리턴한다.
    - hashCode() : 객체에 대한 해시코드 값을 리턴한다.
    - String to String() : 객체를 문자열로 표현하는 값을 리턴한다.
    - wait(), notify(), notifyAll() : 쓰레드 처리시 사용하는 메소드들이다.

---

**■ 1-16. String 클래스**

String 클래스는 자바에서 사용되는 클래스 중 가장 특이한 클래스이다.

- **String 클래스의 특징**
    - new를 사용하여 객체를 생성할 수 있는 유일한 클래스이다.
    - 더하기 연산이 가능하다.
    - 더하기 연산을 할 경우 String 클래스는 기존 문자열은 버리고 새로운 객체를 생성한다. [ 메모리 관점에서 매우 중요하다. 왜냐하면 새로운 객체를 생성하기 때문에 객체를 더하기 기능이 있는 메소드에 매개 변수로 주고 String 더하기 연산을 하면 더한 객체에 대해 heap 영역에 새로운 공간이 할당된다 . 더하기 기능이 있는 그 메소드가 종료되고 매개변수로 준 객체를 호출하면 heap에 새로운 공간으로 할당된 더한 객체가 아니라 자신의 객체가 찍히기 때문이다. 즉, String의 더하기 연산은 객체의 값이 변경한 게 아니라 새로운 값을 할당하여 그 값을 저장을 하기 때문이다 ]
- **String 클래스의 주요 메소드**
    - getBytes() : 문자열을 byte 배열로 변경한다.
    - length() : 문자열의 길이를 리턴한다.
    - isEmpty() : 문자열이 비어 있는지를 확인한다.
    - equals() : 두 문자열의 값이 같은지 확인한다.
    - startsWith(), endsWith() : 매개변수로 넘어온 문자열로 시작하는지, 끝나는지를 확인한다.
    - contains() : 매개변수로 넘어온 문자열이 포함되어 있는지 확인한다.
    - indexOf(), lastIndexOf() : 매개변수로 넘어온 문자열이 있는 위치를 0부터 시작하는 값으로 리턴한다. 만약 없으면 -1을 리턴한다.
    - substring(), subsequence() : 문자열의 특정 범위 값을 잘라서 리턴한다.
    - split() : 문자열을 매개변수로 넘어온 정규 표현식에 따라서 String 배열로 리턴한다.
    - concat() : 기존 문자열 뒤에 매개변수로 넘어온 문자열을 합친다.
    - trim() : 문자열의 맨 앞과 뒤에 있는 공백을 제거한다.
    - replace() : 문자열의 특정 위치의 내용을 매개변수로 넘어온 값으로 변경한다.
    - format() : 문자열을 정해진 포맷으로 변환한다.
    - intern() : 절대로 써서는 안되는 메소드다.
- **StringBuffer와 StringBuilder 클래스**
    - String의 단점을 보완하기 위해서 제공되는 클래스들이다.
    - StringBuffer는 쓰레드에 안전하고, StringBuilder는 그렇지 못하다.
    - append() 메소드를 사용하여 문자열을 더할 수 있다.
    - 만약 문자열을 더하면 컴파일러에서 StringBuilder 클래스로 변환한다.

---

**■ 1-17. 어노테이션을 선언할 때 사용하는 메타 어노테이션들**

어노테이션 선언시 사용하는 메타 어노테이션에는 @Targer, @Retention, @Documented, @Inherited 4가지가 있다.

- JDK에 선언되어 있는 어노테이션
    - @Override : Override한다는 것을 명시적으로 선언할 때 사용한다.
    - @Deperecated : 더 이상 사용하지 않아 Deprecated 되었다는 것을 명시적으로 선언할 때 사용한다.
    - @Supress Warnings : 컴파일러의 경고를 무시하도록 하려고 할 때 사용한다.
- Target 어노테이션에서 사용하는 ElementType의 종류
    - 두 개 이상의 ElementType을 선언할 경우에는 다음과 같이 배열을 선언할 때 처럼 중괄호로 묶어 사용함

> @Target({ElementType.METHOD, ElementType.TYPE})
> 

!https://blog.kakaocdn.net/dn/cMoGG7/btrL9qznd2L/B4xqqOaOLKTglky9WRmO8K/img.png

- Retention 어노테이션에서 사용하는 RetentionPolicy
